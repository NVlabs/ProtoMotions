# SPDX-FileCopyrightText: Copyright (c) 2025 The ProtoMotions Developers
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
"""
# Keypoint Extraction from Packaged MotionLib (.pt file) with Flat Feet and Auxiliary Points

This script extracts 18 key body joint positions and orientations from a
packaged MotionLib file (typically a .pt file generated by motion_lib_v2.py).
Supports both Rigv1 and SMPL skeleton formats.

This version includes special modifications:
- **Flat Feet**: The 'left_foot' and 'right_foot' (ToeBase) keypoints are recalculated
  to be on the same horizontal plane as the ankles, simulating a flat foot pose.
- **Auxiliary Keypoints**: Three additional auxiliary keypoints are generated for the
  hands and pelvis.

## Usage

```bash
python data/scripts/extract_retargeting_input_keypoints_from_packaged_motionlib.py /path/to/your/packaged_motion_lib.pt --skeleton-format rigv1 --output-path /path/to/output_dir
```

## Parameters

- `packaged_motion_lib_file`: Path to the .pt file containing the packaged MotionLib data.
- `--skeleton-format`: Skeleton format to use: 'rigv1' or 'smpl' (default: rigv1).
- `--output-path`: Path to save the extracted keypoints. If not provided, defaults to a
                   '-keypoints-flat-feet-{skeleton_format}' suffixed directory alongside the input .pt file.
- `--force-remake`: Force reprocessing of existing files (default: False).
- `--start-idx`: Start from this motion index (default: 1).
- `--end-idx`: End at this motion index (default: 3500).
- `--skip-freq`: Skip every N motions (default: 35).

## Output

The script creates a directory under `output_path`, containing numpy dictionaries with:
- `positions`: shape `(traj_length, 18, 3)` - XYZ coordinates
- `orientations`: shape `(traj_length, 18, 3, 3)` - rotation matrices
- `left_foot_contacts`: shape `(traj_length, 2)` - contact labels for left ankle and toebase
- `right_foot_contacts`: shape `(traj_length, 2)` - contact labels for right ankle and toebase

The output files are named using a combination of the motion's parent directory and filename from the original dataset.

## Extracted Keypoints (15 base + 3 auxiliary)

The base keypoints are mapped to the appropriate skeleton body names based on skeleton_format:
- For 'rigv1': rigv1_humanoid.xml body names
- For 'smpl': smpl_humanoid.xml body names

1.  pelvis
2.  left_hip
3.  right_hip
4.  left_knee
5.  right_knee
6.  left_ankle
7.  right_ankle
8.  left_foot (*position recalculated for flat foot*)
9.  right_foot (*position recalculated for flat foot*)
10. left_shoulder
11. right_shoulder
12. left_elbow
13. right_elbow
14. left_wrist
15. right_wrist
**--- Auxiliary Keypoints ---**
16. left_hand_aux: Auxiliary point relative to the left wrist. (orthogonal to lower arm vector, forward)
17. right_hand_aux: Auxiliary point relative to the right wrist. (orthogonal to lower arm vector, forward)
18. pelvis_aux: Auxiliary point relative to the pelvis. (forward)
"""

import os
from pathlib import Path
import numpy as np
import torch
import typer

from protomotions.components.motion_lib import MotionLib
from protomotions.components.pose_lib import (
    extract_kinematic_info,
)
from tqdm import tqdm
import time
from datetime import timedelta
from typing import Optional

from keypoint_utils import (
    extract_keypoints_from_motion,
    get_keypoint_indices,
    get_mjcf_path,
)

app = typer.Typer(pretty_exceptions_enable=False)


@app.command()
def main(
    packaged_motion_lib_file: Path = typer.Argument(
        ..., help="Path to the .pt file containing the packaged MotionLib data."
    ),
    output_path: Optional[Path] = typer.Option(
        None,
        help="Path to save the extracted keypoints. If not provided, defaults to a '-keypoints-flat-feet' suffixed directory alongside the input .pt file.",
    ),
    skeleton_format: str = typer.Option(
        "rigv1", "--skeleton-format", help="Skeleton format: 'rigv1' or 'smpl'."
    ),
    force_remake: bool = typer.Option(
        False, "--force-remake", help="Force reprocessing of existing files."
    ),
    start_idx: int = typer.Option(
        1, "--start-idx", help="Start from this motion index."
    ),
    end_idx: Optional[int] = typer.Option(
        None, "--end-idx", help="End at this motion index."
    ),
    skip_freq: int = typer.Option(35, "--skip-freq", help="Skip every N motions."),
):
    device = torch.device("cpu")

    if (
        not packaged_motion_lib_file.is_file()
        or packaged_motion_lib_file.suffix != ".pt"
    ):
        print(f"Error: Input must be a .pt file. Got: {packaged_motion_lib_file}")
        raise typer.Exit(code=1)

    if skeleton_format not in ["rigv1", "smpl"]:
        print(
            f"Error: skeleton_format must be 'rigv1' or 'smpl'. Got: {skeleton_format}"
        )
        raise typer.Exit(code=1)

    if output_path is None:
        output_path = (
            packaged_motion_lib_file.parent
            / f"{packaged_motion_lib_file.stem}_keypoints"
        )

    os.makedirs(output_path, exist_ok=True)
    print(f"Keypoint output directory: {output_path}")

    # Load MotionLib
    from protomotions.components.motion_lib import MotionLibConfig

    motion_lib = MotionLib(
        config=MotionLibConfig(motion_file=str(packaged_motion_lib_file)),
        device=str(device),
    )
    print(f"Loaded MotionLib with {motion_lib.num_motions()} motions.")

    mjcf_file_path = get_mjcf_path(skeleton_format)
    kinematic_info = extract_kinematic_info(mjcf_file_path)

    conceptual_keypoint_names, mjcf_target_body_names, keypoint_indices_in_mjcf = (
        get_keypoint_indices(kinematic_info, skeleton_format)
    )

    if len(keypoint_indices_in_mjcf) != len(conceptual_keypoint_names):
        missing = set(mjcf_target_body_names) - set(kinematic_info.body_names)
        print(
            f"Error: Could not find all target keypoint body names in MJCF. Missing: {missing}"
        )
        raise typer.Exit(code=1)
    print(
        f"Targeting {len(keypoint_indices_in_mjcf)} keypoints: {mjcf_target_body_names}"
    )

    processed_count = 0
    start_time_total = time.time()

    # The coordinate transformations (rot1, rot2) are assumed to have been applied
    # before the .pt file was created (e.g., during the conversion from raw Rigv1 to the format used by MotionLib).
    # Therefore, we do not re-apply them here.

    # for motion_idx in tqdm(range(motion_lib.num_motions()), desc="Processing motions from .pt file"):
    end_idx = motion_lib.num_motions() if end_idx is None else end_idx
    for motion_idx in tqdm(
        range(start_idx, end_idx, skip_freq), desc="Processing motions from .pt file"
    ):
        original_motion_file_path = Path(motion_lib.motion_files[motion_idx])

        print(f"original_motion_file_path: {original_motion_file_path}")

        # Create an identifier from the parent directory name and the file stem
        identifier_stem = (
            f"{original_motion_file_path.parent.name}_{original_motion_file_path.stem}"
        )
        keypoint_output_file = output_path / f"{identifier_stem}_keypoints.npy"

        if not force_remake and keypoint_output_file.exists():
            continue

        try:
            num_frames = motion_lib.motion_num_frames[motion_idx].item()
            start_frame = motion_lib.length_starts[motion_idx].item()
            end_frame = start_frame + num_frames

            # Extract data for the current motion from the MotionLib tensors
            # `motion_lib.gts` (rigid_body_pos) and `motion_lib.grs` (rigid_body_rot)
            # are assumed to contain the final global world-space data for all bodies.

            # Get global positions for all bodies of the current motion
            all_body_positions_current_motion = motion_lib.gts[
                start_frame:end_frame, :, :
            ]
            # Get global rotations (quaternions) for all bodies of the current motion
            all_body_rotations_current_motion_quat = motion_lib.grs[
                start_frame:end_frame, :, :
            ]

            if all_body_positions_current_motion.shape[1] != kinematic_info.num_bodies:
                print(
                    f"Warning: Motion {motion_idx} ({original_motion_file_path.name}) body count mismatch in .pt data. \n"
                    f"Expected {kinematic_info.num_bodies} (MJCF bodies), but found {all_body_positions_current_motion.shape[1]} in motion_lib.gts. \n"
                    f"This script assumes the .pt file stores data aligned with rigv1_humanoid.xml. Skipping."
                )
                continue

            # Get contact data for this motion
            contacts_current_motion = motion_lib.contacts[
                start_frame:end_frame, :
            ]  # [T, N_bodies]

            keypoint_data = extract_keypoints_from_motion(
                all_body_positions=all_body_positions_current_motion,
                all_body_rotations_quat=all_body_rotations_current_motion_quat,
                keypoint_indices_in_mjcf=keypoint_indices_in_mjcf,
                conceptual_keypoint_names=conceptual_keypoint_names,
                device=device,
                skeleton_format=skeleton_format,
                flat_feet=True,
                aux_points=True,
                contacts=contacts_current_motion,
                kinematic_info=kinematic_info,
            )

            # The contact information is now included in keypoint_data
            keypoint_data_to_save = {
                "positions": keypoint_data["positions"].cpu().numpy(),
                "orientations": keypoint_data["orientations"].cpu().numpy(),
                "left_foot_contacts": keypoint_data["left_foot_contacts"],
                "right_foot_contacts": keypoint_data["right_foot_contacts"],
            }
            print(
                f"keypoint_positions.shape: {keypoint_data_to_save['positions'].shape}"
            )
            print(
                f"keypoint_orientations_mat.shape: {keypoint_data_to_save['orientations'].shape}"
            )
            print(
                f"left_foot_contacts.shape: {keypoint_data_to_save['left_foot_contacts'].shape}"
            )
            print(
                f"right_foot_contacts.shape: {keypoint_data_to_save['right_foot_contacts'].shape}"
            )
            print(f"saving to {keypoint_output_file}")
            np.save(str(keypoint_output_file), keypoint_data_to_save)
            processed_count += 1

        except Exception as e:
            print(
                f"Error processing motion index {motion_idx} (file: {original_motion_file_path.name}): {e}"
            )
            import traceback

            traceback.print_exc()
            continue

    end_time_total = time.time()
    total_duration_seconds = end_time_total - start_time_total
    print(
        f"\nSuccessfully processed {processed_count} motions out of {motion_lib.num_motions()}."
    )
    print(f"Total processing time: {timedelta(seconds=int(total_duration_seconds))}")
    if processed_count > 0:
        avg_time = total_duration_seconds / processed_count
        print(f"Average time per file: {timedelta(seconds=int(avg_time))}")


if __name__ == "__main__":
    app()
